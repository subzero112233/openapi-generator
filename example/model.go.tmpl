// WARNING: THIS CODE WAS AUTOMATICALLY GENERATED BY THE API GENERATOR. DO NOT
// EDIT THIS FILE. TO ADD MORE FUNCTIONALITY TO THIS PACKAGE, CREATE NEW FILES
// IN THE SAME DIRECTORY.
package model

import (
	"context"
    "errors"
    "net/http"
    "strconv"
    "strings"
    "time"

	"github.com/mingrammer/commonregex"
)

type {{ api.GoName }} interface {
    {% for method in api.Methods %}
{{ wrapped_comment(80, "    ", method.Summary) }}
    {{ method.GoName }}(ctx context.Context, input {{ method.InputType }}) (
        output {{ method.OutputType }},
        err error,
    )
    {% endfor %}
}

{% for schema in api.Schemas %}
{{ wrapped_comment(80, "", schema.GoName, ": ", schema.Description) }}
type {{ schema.GoName }} struct {
    {% for param in schema.Params %}
{{ wrapped_comment(80, "    ", param.GoName, ": ", param.Description) }}
    {{ param.GoName }} {{ param.GoType }} {{ param.Tags }}

    {% endfor %}
    {% for refSchema in schema.OneOf %}
    *{{ refSchema }}
    {% endfor %}
    {% for refSchema in schema.AllOf %}
    *{{ refSchema }}
    {% endfor %}
    {% for refSchema in schema.AnyOf %}
    *{{ refSchema }}
    {% endfor %}
}
    {% if schema.ErrorFormat != "" %}
// Error returns a string representation of {{ schema.GoName }}
func (err {{ schema.GoName }}) Error() string {
    errMsg := "{{ schema.ErrorFormat }}"
        {% for param in schema.Params %}
            {% if param.GoType == "string" %}
    errMsg = strings.Replace(errMsg, "{{ param.SpecName }}", err.{{ param.GoName }}, -1)
            {% elif param.GoType == "int64" %}
    errMsg = strings.Replace(errMsg, "{{ param.SpecName }}", strconv.FormatInt(err.{{ param.GoName }}, 10), -1)
            {% endif %}
        {% endfor %}

    return errMsg
}
    {% endif %}
// Validate sanitizes and validates {{ schema.GoName }}
// nolint: dupl
func (input *{{ schema.GoName }}) Validate() error {
        {% if schema.AnyOf %}
    var anyFound bool
            {% for refSchema in schema.AnyOf %}
    if input.{{ refSchema }} != nil {
        anyFound = true
        err := input.{{ refSchema }}.Validate()
        if err != nil {
            return err
        }
    }
            {% endfor %}
    if !anyFound {
        return errors.New("Input must contain at least one sub-schema")
    }
        {% endif %}

        {% if schema.OneOf %}
    var oneFound uint8
            {% for refSchema in schema.OneOf %}
    if input.{{ refSchema }} != nil {
        err := input.{{ refSchema }}.Validate()
        if err != nil {
            return err
        }
        oneFound++
    }
            {% endfor %}
    if oneFound != 1 {
        return errors.New("Input must contain at most one sub-schema")
    }
        {% endif %}

        {% if schema.AllOf %}
            {% for refSchema in schema.AllOf %}
    if input.{{ refSchema }} == nil {
        return errors.New("Input must include {{ refSchema }} properties")
    } else {
        err := input.{{ refSchema }}.Validate()
        if err != nil {
            return err
        }
    }
            {% endfor %}
        {% endif %}

        {% for param in schema.Params %}
            {% if api.IsConst(param.GoType) %}
                {% if param.Required %}
    if input.{{ param.GoName }} == "" {
        return errors.New("{{ param.APIName }} must be provided")
    }
                {% endif %}
    if input.{{ param.GoName }} != "" {
        err := input.{{ param.GoName }}.Validate()
        if err != nil {
            return fmt.Errorf("{{ param.APIName }} %s", err)
        }
    }
            {% elif param.GoType == "string" %}
    // trim heading and trailing whitespace from {{ param.GoName }}
    input.{{ param.GoName }} = strings.TrimSpace(input.{{ param.GoName }})
                {% if param.Required %}
    if input.{{ param.GoName }} == "" {
        return errors.New("{{ param.APIName }} must be provided")
    }
                {% elif param.RequiredIf.Needs != "" %}
                    {% with other = schema.GetParam(param.RequiredIf.Needs) %}
                        {% if api.IsConst(other.GoType) %}
    if input.{{ other.GoName }} == {{ api.FindConst(other.GoType, param.RequiredIf.ToBe).GoName }} &&
        input.{{ param.GoName }} == "" {
        return errors.New("{{ param.APIName }} must be provided when {{ other.APIName }} is {{ param.RequiredIf.ToBe }}")
    }
                        {% elif other.GoType == "string" %}
    if input.{{ other.GoName }} == "{{ param.RequiredIf.ToBe }}" &&
        input.{{ param.GoName }} == "" {
        return errors.New("{{ param.APINAme }} must be provided when {{ other.APIName }} is {{ param.RequiredIf.ToBe }}")
    }
                        {% endif %}
                    {% endwith %}
                {% elif param.Default != nil %}
    if input.{{ param.GoName }} == "" {
        input.{{ param.GoName }} = "{{ param.Default }}"
    }
                {% endif %}

                {% if param.MinLength != nil %}
    if len(input.{{ param.GoName }}) < {{ param.MinLength }} {
        return errors.New("{{ param.APIName }} must have at least {{ param.MinLength }} characters")
    }
                {% endif %}

                {% if param.MaxLength != nil %}
    if len(input.{{ param.GoName }}) > {{ param.MaxLength }} {
        return errors.New("{{ param.APIName }} must have at most {{ param.MaxLength }} characters")
    }
                {% endif %}
            {% elif param.GoType == "int64" || param.GoType == "int32" || param.GoType == "uint64" || param.GoType == "uint32" || param.GoType == "uint16" || param.GoType == "uint8" %}
                {% if param.Required %}
    if input.{{ param.GoName }} == 0 {
        return errors.New("{{ param.GoName }} must be provided")
    }
                {% elif param.Default != nil %}
    if input.{{ param.GoName }} == 0 {
        input.{{ param.GoName }} = {{ param.Default }}
    }
                {% endif %}

                {% if param.GoType|first == "i" && param.Minimum != nil %}
    if input.{{ param.GoName }} < {{ param.Minimum }} {
        return errors.New("{{ param.APIName }} cannot be lower than {{ param.Minimum }}")
    }
                {% endif %}

                {% if param.Maximum != nil %}
    if input.{{ param.GoName }} > {{ param.Maximum }} {
        return errors.New("{{ param.APIName }} cannot be larger than {{ param.Maximum }}")
    }
                {% endif %}
            {% elif param.IsArray && api.IsConst(param.ArrayItemGoType) %}
    if len(input.{{ param.GoName }}) > 0 {
        for _, val := range input.{{ param.GoName }} {
            err := val.Validate()
            if err != nil {
                return err
            }
        }
    }
            {% endif %}

            {% if param.ValidURL %}
    if input.{{ param.GoName }} != "" {
		if !commonregex.LinkRegex.MatchString(input.{{ param.GoName }}) {
			return errors.New("{{ param.APIName }} must be a valid URL")
		}
    }
            {% endif %}
        {% endfor %}

    return nil
}
{% endfor %}

{% for c in api.Consts %}
type {{ c.Name }} string

const (
    {% for value in c.Values %}{{ value.GoName }} {{ c.Name }} = "{{ value.APIName }}"
    {% endfor %}
)

var All{{ c.Name }} = []{{ c.Name }}{
    {% for v in c.Values %}{{ v.GoName }},
    {% endfor %}
}

var All{{ c.Name }}String = []string{
    {% for v in c.Values %}"{{ v.APIName }}",
    {% endfor %}
}

func (val {{ c.Name }}) Validate() error {
    for _, a := range All{{ c.Name }} {
        if val == a {
            return nil
        }
    }

    // nolint: lll
    return fmt.Errorf("must be one of %s", strings.Join(All{{ c.Name }}String, ", "))
}
{% endfor %}
